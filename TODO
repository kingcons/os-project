**Brit's TODO
From highest priority to lowest...

1.
Get scheduler loading ready-queue and memory until next job exceeds memory capacity.
- How to best do this?
-- Obvious solution: Compute next job size from *PCB*, ensure it fits in remaining space.
- How to iterate though jobs?
-- Obvious solution: Loop through *PCB* checking status?
--- Set :in-disk or :in-memory during loads, ignoring :terminated/finished?
--- Ensure status field in PCB is being set appropriately throughout program.
- Likely need to rewrite load-job to do the present work of context switch.
-- Breg, pc etc are always set to 0.

2.
Test decode and fetch on job 1.
Ensure jobs transition and CPU eventaully halts.

3.
Look at profiling and timing methods.
- Where to store?
-- In PCB seems rather obvious, or in another hashtable that takes job-ids as keys.
- What's in a job-profile object?
-- IO ops (load/stores), Time in waiting queue and  Total Completion Time as a bare minimum.
- How to profile?
-- See if the output from time can be redirected. If not, write a record-runtime macro or similar.

4. *Very Low Priority, Speculative*
Ensure correctness of MOV.

;; Watch lecture 01 again, ensure conformance to ideas about RQ/Scheduler + PCB?

Long Term/Fun:
Just make the code ungross.
Work on style, eliminate hacks, improve readability+formatting, etc.
-- Abstract things where possible. Use macros where necessary/sane.
--- Potential targets:
---- Cpu.lisp is easily the ugliest code in the whole project.
----- Decode in particular is 120 lines of raw madness. Refactor, rewrite, sanify.
---- Unify load-job and unload-job. That is totally one function waiting to happen.

**Justin's TODO

1. OS Driver (or Kernel, aka Main Loop)

2. Documentation (Report)

3. Manually work out 3-4 jobs and check against OS output